#version 450
layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

layout(std430, binding = 0) writeonly buffer Normal{
	float d_normal[];
};
layout(binding = 1) readonly buffer CellScan{
	uint cell_scan[];
};
layout(binding = 2) readonly buffer Face{
	uint faces[];
};
layout(std430, binding = 3) readonly buffer Vertex{
	float vertices[];
};
layout(std140, binding = 4) uniform MetaInfo{
	uvec3 dim;
	float isovalue;
};

void main(){
	uvec3 thread_id = gl_LocalInvocationID + gl_WorkGroupSize * gl_WorkGroupID;
	uint limit = cell_scan[dim.x * dim.y * dim.z - 1];
	uint idx = thread_id.x + thread_id.y * dim.x + thread_id.z * dim.x * dim.y;
	if( idx >= limit ) return ;
	uint face_offset = 3*idx;
	uint vertex_offset = faces[face_offset];
	vec3 p0 = vec3(
		vertices[vertex_offset], 
		vertices[vertex_offset + 1], 
		vertices[vertex_offset + 2] );
	vertex_offset = faces[face_offset + 1];
	vec3 p1 = vec3(
		vertices[vertex_offset], 
		vertices[vertex_offset + 1], 
		vertices[vertex_offset + 2]);
	vertex_offset = faces[face_offset + +2];
	vec3 p2 = vec3(
		vertices[vertex_offset], 
		vertices[vertex_offset + 1], 
		vertices[vertex_offset + 2] );
	p0 = (p0 + p1 + p2)/3.0f;
	p0 = normalize(p0);
	d_normal[3*idx] = p0.x;
	d_normal[3*idx + 1] = p0.y;
	d_normal[3*idx + 2] = p0.z;
}